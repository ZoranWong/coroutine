<?php


namespace ZoranWong\Coroutine;


use Closure;
use Generator;

//协程
class CTread extends Coroutine implements Runnable
{
    const STATE_NEW = 0;
    const STATE_READY = 1;
    const STATE_RUNNING = 2;
    const STATE_BLOCKING = 3;
    const STATE_DEAD = 4;

    protected $state = 0;
    protected $runnable = null;
    protected $started = false;
    protected $interrupt = false;
    protected $parentId = null;

    public function __construct($runnable = null, Task $task = null, string $name = '')
    {
        $this->state = self::STATE_NEW;
        $this->runnable = $runnable ? $runnable : $this;
        $name = $name ? $name : uniqid(get_class($this->runnable));
        $coroutine = $this->run();
        parent::__construct($coroutine, $task, $name);
    }


    /**
     * @return Generator
     * */
    public function run()
    {
        if ($this->runnable instanceof Closure) {
            $runnable = $this->runnable;
            yield (function () use ($runnable) {
                Scheduler::$currentTask = $this->task;
                Scheduler::$currentTaskId = $this->task ? $this->task->getTaskId() : null;
                yield $runnable($this->task);
            })();
        } else {
            if ($this->runnable instanceof Runnable) {
                yield (function () {
                    yield $this->runnable->run();
                })();
            } else if ($this->runnable instanceof Coroutine) {
                yield (function () {
                    $this->runnable;
                })();
            }
        }
    }

    public function rewind()
    {
        $this->resetStack($this->run());
        parent::rewind(); // TODO: Change the autogenerated stub
    }


    public function checkState()
    {
        if (!$this->isFinished()) {
            if ($this->interrupt) {
                $this->state = self::STATE_BLOCKING;
            } elseif ($this->started) {
                $this->state = self::STATE_RUNNING;
            } else {
                $this->state = self::STATE_READY;
            }
        } else {
            $this->state = self::STATE_DEAD;
        }
    }

    public function ready()
    {
        if ($this->valid()) {
            $this->state = self::STATE_RUNNING;
        } else {
            $this->state = self::STATE_DEAD;
        }
    }

    public function block()
    {
        if ($this->valid()) {
            if ($this->interrupt)
                $this->state = self::STATE_BLOCKING;
        } else {
            $this->state = self::STATE_DEAD;
        }
    }

    public function start()
    {
        $this->task = Scheduler::add($this);
        if ($this->started) {
            if ($this->valid()) {
                $this->state = self::STATE_RUNNING;
                $this->started = true;
            } else {
                $this->state = self::STATE_DEAD;
                $this->started = true;
            }
        }
    }

    public function join(int $waitTime = 0)
    {
        $start = microtime(true) * 1000;
        $end =  $waitTime > 0? ($waitTime + $start) : 0;
        Scheduler::join($this->task, $end);
    }
}